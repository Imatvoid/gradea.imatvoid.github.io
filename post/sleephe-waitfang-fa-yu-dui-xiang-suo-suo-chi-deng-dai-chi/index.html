<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>sleep()和wait()方法与对象锁、锁池、等待池 | Imatvoid </title>
<meta name="description" content="未曾清贫难成人，不经打击老天真。 &lt;/br&gt;
自古英雄出炼狱，从来富贵入凡尘。 ">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://imatvoid.github.io//favicon.ico?v=1562484694479">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://imatvoid.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://imatvoid.github.io/">
        <img src="https://imatvoid.github.io//images/avatar.png?v=1562484694479" class="site-logo">
        <h1 class="site-title">Imatvoid </h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://imatvoid.github.io/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://imatvoid.github.io//archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://imatvoid.github.io//tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://imatvoid.github.io//post/about/" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      未曾清贫难成人，不经打击老天真。 </br>
自古英雄出炼狱，从来富贵入凡尘。 
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://imatvoid.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">sleep()和wait()方法与对象锁、锁池、等待池</h2>
            <div class="post-date">2016-11-28</div>
            
            <div class="post-content">
              <p>一道Java的题目:</p>
<blockquote>
<p>关于sleep()和wait()，以下描述错误的一项是:<br>
A sleep是线程类（Thread）的方法，wait是Object类的方法<br>
B sleep不释放对象锁，wait放弃对象锁<br>
C sleep暂停线程、但监控状态仍然保持，结束后会自动恢复<br>
D wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态</p>
</blockquote>
<!-- more -->
<h2 id="关于对象锁">关于对象锁</h2>
<p><strong>截取网上的一段话</strong>：</p>
<blockquote>
<p>所有对象都自动含有单一的锁。<br>
JVM负责跟踪对象被加锁的次数。如果一个对象被解锁，其计数变为0。在任务（线程）第一次给对象加锁的时候，计数变为1。每当这个相同的任务（线程）在此对象上获得锁时，计数会递增。<br>
只有首先获得锁的任务（线程）才能再次加锁(锁的重入)。<br>
每当任务离开一个synchronized（同步）方法，计数递减，当计数为0的时候，锁被完全释放，此时别的任务就可以使用此资源。</p>
</blockquote>
<h2 id="关于锁池和等待池">关于锁池和等待池</h2>
<blockquote>
<p>虽然java底层使用队列实现的,但是用池来描述会更容易理解,后面会看到</p>
</blockquote>
<p>在Java中，每个对象都有两个池，锁(monitor)池和等待池</p>
<ul>
<li>
<p>锁池:假设线程A已经拥有了某个对象的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</p>
</li>
<li>
<p>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。<br>
如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.</p>
<p><img src="https://imatvoid.github.io//post-images/1561822230431.png" alt=""></p>
</li>
</ul>
<h2 id="深入理解">深入理解</h2>
<p>如果线程调用了对象的 wait()方法，那么线程便会释放锁进入该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。
优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>
<p>注：wait() ,notifyAll(),notify() 三个方法都是Object类中的方法.</p>
<h3 id="关于wait-notifyallnotify-三个方法">关于wait() ,notifyAll(),notify() 三个方法</h3>
<h4 id="wait">wait()</h4>
<p>public final void wait() throws InterruptedException,IllegalMonitorStateException</p>
<p>该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用 wait()之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用 wait()方法。进入 wait()方法后，当前线程释放锁。在从 wait()返回前，线程与其他线程竞争重新获得锁。如果调用 wait()时，没有持有适当的锁，则抛出 IllegalMonitorStateException，它是 RuntimeException 的一个子类，因此，不需要 try-catch 结构。</p>
<h4 id="notify">notify()</h4>
<p>public final native void notify() throws IllegalMonitorStateException</p>
<p>该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用 notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。</p>
<p>该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个 wait()状态的线程来发出通知，并使它等待获取该对象的对象锁.<br>
这里有两个注意点:<br>
1.<strong>notify 后，当前线程不会马上释放该对象锁，wait 所在的线程并不能马上获取该对象锁，要等到程序退出 synchronized 代码块后，当前线程才会释放锁，某一个wait所在的线程也才可以获取该对象锁
但不惊动其他同样在等待池中等待被notify的线程们。</strong><br>
2.<strong>当第一个获得了该对象锁的 wait 线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他 wait 状态等待的线程由于没有得到该对象的通知，会继续在等待池中,阻塞在 wait 状态，直到这个对象发出一个 notify 或 notifyAll。<br>
这里需要注意：等待池中的线程们等待的是被 notify 或 notifyAll，暂时还不是锁。这与下面的 notifyAll()方法执行后的情况不同。</strong></p>
<h4 id="notifyall">notifyAll()</h4>
<p>public final native void notifyAll() throws IllegalMonitorStateException</p>
<p>该方法与 notify ()方法的工作方式相同，重要的一点差异是：</p>
<p>notifyAll 使所有原来在该对象上 wait 的线程统统退出 wait 的状态（即全部被唤醒,从等待池移动到锁池,不再等待 notify 或 notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成在锁池中等待获取该对象上的锁.<br>
一旦该对象锁被释放（notifyAll 线程退出调用了 notifyAll 的 synchronized 代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出 synchronized 代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p>
<h2 id="sleep不会释放掉锁">sleep()不会释放掉锁</h2>
<p>最开始的那道题答案是D,notifyAll()也可以</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://imatvoid.github.io//tag/5pBSGnoY5" class="tag">
                    java并发
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://imatvoid.github.io//post/maven-cai-keng-javalangoutofmemoryerror-java-heap-space">
                  <h3 class="post-title">
                    Maven 踩坑 -- java.lang.OutOfMemoryError
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'd6f8edd37708580f1f7e',
        clientSecret: 'd0b6a8d54d73512cc1e86256bfd778b4753e6b6c',
        repo: 'imatvoid.github.io',
        owner: 'Imatvoid',
        admin: ['Imatvoid'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
